<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8"> <![endif]-->
<!--[if IE 9]> <html lang="en" class="ie9"> <![endif]-->
<!--[if !IE]><!--> <html lang="en"> <!--<![endif]-->
<head>
<title>Codurance - Applying Transformation Priority Premise to Roman Numerals Kata</title>
 <!-- Meta -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="author" content="">

<!-- Open Graph tags - Used when publishing on Facebook -->
<meta property="og:site_name" content="Codurance"/>
<meta property="og:description" content="We build well-crafted software"/>
<meta property="og:url" content="http://codurance.com"/>
<meta property="og:image" content="http://codurance.com/assets/img/codurance.png"/>

<!-- Favicon -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">

<!-- CSS Global Compulsory -->
<link rel="stylesheet" href="/assets/plugins/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/assets/css/style.css">

<!-- CSS Implementing Plugins -->
<link rel="stylesheet" href="/assets/plugins/line-icons/line-icons.css">
<link rel="stylesheet" href="/assets/plugins/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/assets/plugins/owl-carousel/owl-carousel/owl.carousel.css">

<!-- CSS Theme -->
<link rel="stylesheet" href="/assets/css/plugins.css">
<link rel="stylesheet" href="/assets/css/app.css">
<link rel="stylesheet" href="/assets/css/theme-colors/orange.css" id="style_color">

<!-- CSS Customization -->
<link rel="stylesheet" href="/assets/css/custom.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/idea.min.css">
<!--fonts -->
<link href='http://fonts.googleapis.com/css?family=Oxygen:700,400' rel='stylesheet' type='text/css'>



<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-46289079-1', 'codurance.com');
    ga('send', 'pageview');
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<div class="wrapper">
<!--=== Header ===-->
<div class="header-v3 header-sticky">
        <!-- Navbar -->
        <div class="navbar navbar-default" role="navigation">
            <div class="container">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="fa fa-bars"></span>
                    </button>
                    <a class="navbar-brand" href="/">
                        <img id="logo-header" src="/assets/img/codurance.png" height="45px;" alt="Logo">
                    </a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse navbar-responsive-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="/services">Services</a></li>
                        <li><a href="/casestudies">Case Studies</a></li>
                        <li><a href="/videos">Videos</a></li>
                        <li><a href="/blog">Blog</a></li>
                        <li><a href="/careers/craftsman">Work with us</a></li>
                        <li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown">About Us <i class="icon-angle-down">&nbsp;</i></a><ul class="dropdown-menu">
                            <li><a href="/aboutus/ourteam">Our Team</a></li>
                            <li><a href="/aboutus/ourcompany">Our Company</a></li>
                            <li><a href="/aboutus/ourpractices">Our Practices</a></li>
                        </ul></li>
                    </ul>
                </div><!--/navbar-collapse-->
            </div>    
        </div>            
        <!-- End Navbar -->
    </div>
    <!--=== End Header ===--> 

<!--=== End Header ===-->


    <div class="breadcrumbs margin-bottom-10">
        <div class="container">
            <h2 class="pull-left">Applying Transformation Priority Premise to Roman Numerals Kata</h2>
            <ul class="pull-right breadcrumb">
                <li><a href="/">Home</a></li>
                
                    <li>
                    
                        <a href="/blog">Blog</a>
                    
                    </li>
                
            </ul>
        </div>
    </div>



<div class="container">
<div class="row blog-page blog-item">
<!-- Left Sidebar -->
<div class="col-md-9 md-margin-bottom-60">
    <!--Blog Post-->
    <div class="blog margin-bottom-40">
        
        <div class="blog-post-tags">
            <ul class="list-unstyled list-inline blog-info">
                <li><i class="fa fa-calendar"></i> 18 May 2015</li>
                <li><i class="fa fa-pencil"></i> Pedro Santos</li>
                <li class="blog-share-buttons">
                  <script src="//platform.linkedin.com/in.js" type="text/javascript"> lang: en_US</script>
                  <script type="IN/Share"></script>

                  <a class="twitter-share-button"
                      href="https://twitter.com/intent/tweet?url=http://www.codurance.com/2015/05/18/applying-transformation-priority-premise-to-roman-numerals-kata/"
                      data-count="none">
                      Tweet</a>
                </li>
            </ul>
        </div>
        

        
            <img class="img-responsive thumbnail blog-post-image" src="/assets/img/custom/blog/2015-05-11-applying-transformation-priority-premise-to-roman-numerals-kata/She-wolf_suckles_Romulus_and_Remus.jpg" alt="Applying Transformation Priority Premise to Roman Numerals Kata">
        

        <h1>Applying Transformation Priority Premise to Roman Numerals Kata</h1>

<blockquote><p>"As tests get more specific code gets more generic." - Uncle Bob</p></blockquote>

<h2>TDD</h2>

<p>Often one of the doubts we have when developing software driven by tests is how to evolve code in small and steady paces guided by tests (baby steps). TDD looks deceptively easy and only when we get more experience do we recognize this. The three laws of TDD state:</p>

<ol>
<li>You are not allowed to write any production code unless it is to make a failing unit test pass.</li>
<li>You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.</li>
<li>You are not allowed to write any more production code than is sufficient to pass the one failing unit test.</li>
</ol>


<p>On this post I would like to concentrate on the third law.
On May 2013 Robert C. Martin AKA Uncle Bob wrote a seminal post titled <a href="http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">"Transformation Priority Premise"</a>. Go read it, I will wait here. Alternatively <a href="https://vimeo.com/97516288">watch</a> him talk about it.</p>

<h2>What is this post about?</h2>

<p>I had to prepare a presentation on Transformation Priority Premise. I tried to document how I could use this technique to implement an algorithm. My objective was to implement it trying not to skip any of the transformations and moving through them in the order they are defined.</p>

<h2>Transformation Priority Premise</h2>

<p>The transformations list gives guidance on how to apply small transformations to the code under test in order to evolve it to a more generic implementation. We should try to avoid taking big leaps forward when a small transformation will do. Remember the third law of TDD: "You are not allowed to write any more production code than is sufficient to pass the one failing unit test." "Transformations on the top of the list should be preferred to those that are lower. It is better (or simpler) to change a constant into a variable than it is to add an if statement. So when making a test pass, you try to do so with transformations that are simpler (higher on the list) than those that are more complex."
On the table below you can find the transformations list.</p>

<ol>
<li>({} -> nil) no code at all->code that employs nil</li>
<li>(nil -> constant)</li>
<li>(constant -> constant+) a simple constant to a more complex constant</li>
<li>(constant -> scalar) replacing a constant with a variable or an argument</li>
<li>(statement -> statements) adding more unconditional statements.</li>
<li>(unconditional -> if) splitting the execution path</li>
<li>(scalar -> array)</li>
<li>(array -> container)</li>
<li>(statement -> recursion)</li>
<li>(if -> while)</li>
<li>(expression -> function) replacing an expression with a function or algorithm</li>
<li>(variable -> assignment) replacing the value of a variable.</li>
</ol>


<h2>Roman Numbers</h2>

<p>If you are familiar with this kata please move to the next section implementation.</p>

<h3>Definition</h3>

<p>Given a positive integer number (eg. 42) determine its Roman numeral representation as a String (eg "XLII"). You cannot write numerals like IM for 999.</p>

<h3>Examples</h3>

<table>
<thead>
<tr>
<th>Arabic number      </th>
<th>Roman numeral  </th>
<th>Arabic number      </th>
<th>Roman numeral  </th>
</tr>
</thead>
<tbody>
<tr>
<td>1                        </td>
<td>I                      </td>
<td>60                         </td>
<td>LX                   </td>
</tr>
<tr>
<td>2                </td>
<td>II               </td>
<td>70               </td>
<td>LXXX           </td>
</tr>
<tr>
<td>3                </td>
<td>III            </td>
<td>80               </td>
<td>LXXX           </td>
</tr>
<tr>
<td>4                </td>
<td>IV             </td>
<td>90                 </td>
<td>XC             </td>
</tr>
<tr>
<td>5                </td>
<td>V              </td>
<td>100              </td>
<td>C              </td>
</tr>
<tr>
<td>6                </td>
<td>VI               </td>
<td>200                </td>
<td>CC             </td>
</tr>
<tr>
<td>7                </td>
<td>VII            </td>
<td>300              </td>
<td>CCC            </td>
</tr>
<tr>
<td>8                </td>
<td>VIII           </td>
<td>400              </td>
<td>CD             </td>
</tr>
<tr>
<td>9                </td>
<td>IX               </td>
<td>500                </td>
<td>D              </td>
</tr>
<tr>
<td>10               </td>
<td>X                </td>
<td>600                </td>
<td>DC             </td>
</tr>
<tr>
<td>20               </td>
<td>XX               </td>
<td>700                </td>
<td>DCC            </td>
</tr>
<tr>
<td>30               </td>
<td>XXX            </td>
<td>800              </td>
<td>DCCC           </td>
</tr>
<tr>
<td>40               </td>
<td>XL               </td>
<td>900                </td>
<td>CM             </td>
</tr>
<tr>
<td>50               </td>
<td>L              </td>
<td>1000             </td>
<td>M              </td>
</tr>
</tbody>
</table>


<table>
<thead>
<tr>
<th>Arabic number</th>
<th>Roman numeral</th>
<th>Thousands</th>
<th>Cents</th>
<th>Tenths</th>
<th>Units</th>
</tr>
</thead>
<tbody>
<tr>
<td>846          </td>
<td>DCCCXLVI     </td>
<td>-        </td>
<td>DCC  </td>
<td>XL    </td>
<td>VI   </td>
</tr>
<tr>
<td>1999         </td>
<td>MCMXCIX      </td>
<td>M        </td>
<td>CM   </td>
<td>XC    </td>
<td>IX   </td>
</tr>
<tr>
<td>2008         </td>
<td>MMVIII       </td>
<td>MM       </td>
<td>-    </td>
<td>-     </td>
<td>VIII </td>
</tr>
</tbody>
</table>


<h2>Implementation</h2>

<p>We start by writing the simplest unit test we can think of.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}
</code></pre>

<p>We start the implementation using the first transformation <em>no code to nil</em></p>

<pre><code class="csharp">// 1 nil
public class RomanConverter
{
    public string Convert(int number)
    {
        return null;
    }
}
</code></pre>

<p>The first transformation is not enough to make the test pass so we apply the second transformation <em>nil to constant</em>. This is enough to make the test pass so we stop evolving the code until we have a failing test.</p>

<pre><code class="csharp">// 2 nil -&gt; constant
public class RomanConverter
{
    public string Convert(int number)
    {
        return "I";
    }
}
</code></pre>

<p>We add a new failing test.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}
</code></pre>

<p>The next transformation <em>constant to variable</em> is not sufficient to make the test pass.</p>

<pre><code class="csharp">// 4 Constant -&gt; variable
public class RomanConverter
{
    public string Convert(int number)
    {
        var result = "I";
        return result;
    }
}
</code></pre>

<p>The next transformation <em>statement to statements</em> is also not sufficient to make the test pass.</p>

<pre><code class="csharp">// 5 statement -&gt; statements
public class RomanConverter
{
    public string Convert(int number)
    {
        var result = "I";
        result += "I";

        return result;
    }
}
</code></pre>

<p>Applying the next transformation <em>unconditional to conditional</em> is sufficient to make the test pass.</p>

<pre><code class="csharp">// 6 unconditional -&gt; conditional
public class RomanConverter
{
    public string Convert(int number)
    {
        var result = "I";

        if (number &gt;= 1)
        {
            result += "I";
        }

        return result;
    }
}
</code></pre>

<p>We add a new failing test.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    [TestCase(3, "III")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}
</code></pre>

<p>Adding another conditional will make the test pass, but we have duplication.</p>

<pre><code class="csharp">public class RomanConverter
{
    public string Convert(int number)
    {
        var result = "I";
        if (number &gt; 1)
        {
            result += "I";
        }

        if (number &gt; 2)
        {
            result += "I";
        }

        return result;
    }
}
</code></pre>

<p>Applying the next transformation <em>variable to array</em> removes the duplication.</p>

<pre><code class="csharp">// 7 variable -&gt; array
public class RomanConverter
{
    public static readonly string[] Results = { "I", "II", "III" };

    public string Convert(int number)
    {
        return Results[number - 1];
    }
}
</code></pre>

<p>We add a new failing test.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    [TestCase(3, "III")]
    [TestCase(4, "IV")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}
</code></pre>

<p>To make the test pass we don't need to apply the next transformation, we can make the test pass by adding a new element to the array.</p>

<pre><code class="csharp">// no transformation
public class RomanConverter
{
    public static readonly string[] Results = { "I", "II", "III", "IV" };

    public string Convert(int number)
    {
        return Results[number - 1];
    }
}
</code></pre>

<p>While adding a new element to the array was enough to make the test pass, we now spot some duplication on character "I". By applying the next transformation <em>statement to tail</em> recursion we can get rid of this duplication. Since we are trying to follow the transformation table we applied the <em>array to collection</em> transformation before the tail recursion.</p>

<pre><code class="csharp">// 8 array -&gt; collection
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results =
        new Dictionary&lt;int, string&gt;
        {
            {1, "I"},
            {2, "II"},
            {3, "III"},
            {4, "IV"},
        };

    public string Convert(int number)
    {
        return Results[number];
    }
}

// 9 statement -&gt; tail recursion
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results = new Dictionary&lt;int, string&gt;
    {
        {1, "I"},
        {4, "IV"},
    };

    public string Convert(int number)
    {
        if (Results.ContainsKey(number))
        {
            return Results[number];
        }

        return Results[1] + Convert(number - 1);
    }
}
</code></pre>

<p>We add a few more failing tests but since the last transformation was still allowing us to make tests pass we waited until we had duplication to refactor.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    [TestCase(3, "III")]
    [TestCase(4, "IV")]
    [TestCase(5, "V")]
    [TestCase(6, "VI")]
    [TestCase(7, "VII")]
    [TestCase(8, "VIII")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}
</code></pre>

<p>No other transformations required, simply adding new values to the dictionary allowed us to make the tests pass but we can now spot duplication, again around character "I".</p>

<pre><code class="csharp">public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results =
    new Dictionary&lt;int, string&gt;
    {
        {1, "I"},
        {4, "IV"},
        {5, "V"},
        {6, "VI"},
        {7, "VII"},
        {8, "VIII"},
    };

    public string Convert(int number)
    {
        if (Results.ContainsKey(number))
        {
            return Results[number];
        }

        return Results[1] + Convert(number - 1);
    }
}
</code></pre>

<p>To fix the duplication we apply again the transformation, <em>statement to tail recursion</em>, to fix this. We don't yet need to move to the next transformation.</p>

<pre><code class="csharp">// 9 statement -&gt; tail recursion
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results =
    new Dictionary&lt;int, string&gt;
    {
        {1, "I"},
        {4, "IV"},
        {5, "V"},
    };

    public string Convert(int number)
    {
        if (Results.ContainsKey(number))
        {
            return Results[number];
        }

        if (number &gt; 5)
        {
            const string result = "V";
            return result + Convert(number - 5);
        }

        return Results[1] + Convert(number - 1);
    }
}
</code></pre>

<p>Again we add more failing tests, and again, the last transformation is still making tests pass.</p>

<pre><code class="csharp">[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    [TestCase(3, "III")]
    [TestCase(4, "IV")]
    [TestCase(5, "V")]
    [TestCase(6, "VI")]
    [TestCase(7, "VII")]
    [TestCase(8, "VIII")]
    [TestCase(9, "IX")]
    [TestCase(10, "X")]
    [TestCase(40, "XL")]
    [TestCase(44, "XLIV")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}

// Wait for patterns to emerge
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results =
        new Dictionary&lt;int, string&gt;
        {
            {1, "I"},
            {4, "IV"},
            {5, "V"},
            {9, "IX"},
            {10, "X"},
            {40, "XL"},
        };

    public string Convert(int number)
    {
        if (Results.ContainsKey(number))
        {
            return Results[number];
        }

        if (number &gt; 40)
        {
            const string result = "XL";
            return result + Convert(number - 40);
        }

        if (number &gt; 10)
        {
            const string result = "X";
            return result + Convert(number - 10);
        }

        if (number &gt; 5)
        {
            const string result = "V";
            return result + Convert(number - 5);
        }

        return Results[1] + Convert(number - 1);
    }
}
</code></pre>

<p>We spot duplication around if statements, so we refactor the code to the next transformation <em>if to while</em>. This gets rid of if statement duplication, but we now have while statement duplication.</p>

<pre><code class="csharp">// 10 if -&gt; while
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; Results =
        new Dictionary&lt;int, string&gt;
        {
            {1, "I"},
            {4, "IV"},
            {5, "V"},
            {9, "IX"},
            {10, "X"},
            {40, "XL"},
        };

    public string Convert(int number)
    {
        if (Results.ContainsKey(number))
        {
            return Results[number];
        }

        string result = string.Empty;

        while (number &gt;= 40)
        {
            result += "XL";
            number -= 40;
        }

        while (number &gt;= 10)
        {
            result += "X";
            number -= 10;
        }

        while (number &gt;= 5)
        {
            result += "V";
            number -= 5;
        }

        while (number &gt;= 4)
        {
            result += "IV";
            number -= 4;
        }

        while (number &gt;= 1)
        {
            result += "I";
            number -= 1;
        }

        return result;
    }
}
</code></pre>

<p>We apply the same <em>if to while</em> transformation to the remaining if statement and this allows us to get rid of the duplicated while statements. In order for this to work it's more convenient to have the dictionary reversed so we also do this.</p>

<pre><code class="csharp">// 10 if -&gt; while
public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; mappings =
        new Dictionary&lt;int, string&gt;
        {
            {40, "XL"},
            {10, "X"},
            {9, "IX"},
            {5, "V"},
            {4, "IV"},
            {1, "I"},
        };

    public string Convert(int number)
    {
        string result = string.Empty;
        var mappingsEnumerator = mappings.GetEnumerator();

        while (mappingsEnumerator.MoveNext())
        {
            var mapping = mappingsEnumerator.Current;

            while (number &gt;= mapping.Key)
            {
                result += mapping.Value;
                number -= mapping.Key;
            }
        }

        return result;
    }
}
</code></pre>

<p>We add more failing tests but the last transformation is sufficient to make all new tests pass and we cannot think of anymore failing tests, this implies we are done. We refactor the code to make it more readable and we are done. We decided not to refactor the outer while loop to a foreach loop. Although this could simplify the code, a foreach loop is not in the transformation premise list so we decided against it for the purposes of this post.</p>

<pre><code class="csharp">// final solution
[TestFixture]
public class RomanConverterShould
{
    [TestCase(1, "I")]
    [TestCase(2, "II")]
    [TestCase(3, "III")]
    [TestCase(4, "IV")]
    [TestCase(5, "V")]
    [TestCase(6, "VI")]
    [TestCase(7, "VII")]
    [TestCase(8, "VIII")]
    [TestCase(9, "IX")]
    [TestCase(10, "X")]
    [TestCase(40, "XL")]
    [TestCase(50, "L")]
    [TestCase(90, "XC")]
    [TestCase(100, "C")]
    [TestCase(400, "CD")]
    [TestCase(500, "D")]
    [TestCase(900, "CM")]
    [TestCase(1000, "M")]
    [TestCase(846, "DCCCXLVI")]
    [TestCase(1999, "MCMXCIX")]
    [TestCase(2008, "MMVIII")]
    public void ConvertNumberToRoman(int number, string expected)
    {
        var romanNumeral = new RomanConverter().Convert(number);
        Assert.That(romanNumeral, Is.EqualTo(expected));
    }
}

public class RomanConverter
{
    public static readonly IDictionary&lt;int, string&gt; arabicsToRomans =
            new Dictionary&lt;int, string&gt;
            {
                {1000, "M"},
                {900, "CM"},
                {500, "D"},
                {400, "CD"},
                {100, "C"},
                {90, "XC"},
                {50, "L"},
                {40, "XL"},
                {10, "X"},
                {9, "IX"},
                {5, "V"},
                {4, "IV"},
                {1, "I"},
            };

        public string Convert(int number)
        {
            var romanNumeral = string.Empty;
            var arabicsToRomansEnumerator = arabicsToRomans.GetEnumerator();

            while (arabicsToRomansEnumerator.MoveNext())
            {
                var arabicToRoman = arabicsToRomansEnumerator.Current;
                var arabicNumeral = arabicToRoman.Key;
                var romanNumeral = arabicToRoman.Value;

                while (number &gt;= arabicNumeral)
                {
                    result += romanNumeral;
                    number -= arabicNumeral;
                }
            }

            return romanNumeral;
        }
    }
}
</code></pre>

<h2>Conclusions</h2>

<p>For the purpose of this post I think the code as is, illustrates the process described by Robert Martin, AKA Uncle Bob, to refactor code from specific to generic guided by tests. Deliberately following the Transformation Priority Premise while coding was a very interesting exercise, it provided guidance while avoiding big leap refactors. I found out that when I was stuck, most of the time, the solution was just applying the next transformation on the table.</p>

<h2>Links</h2>

<p><a href="http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html</a></p>

<p><a href="https://vimeo.com/97516288">https://vimeo.com/97516288</a></p>

<p><a href="http://en.wikipedia.org/wiki/Transformation_Priority_Premise">http://en.wikipedia.org/wiki/Transformation_Priority_Premise</a></p>


        
    </div>
    <!--End Blog Post-->
</div>
<!-- End Left Sidebar -->

<!-- Right Sidebar -->
<div class="col-md-3 magazine-page">
    <!-- Blog Latest Tweets -->
    <div class="blog-twitter margin-bottom-30">
        <a class="twitter-timeline" href="https://twitter.com/mashooq/codurance" data-widget-id="400789734676385792">Tweets from Codurance team</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script>window.twttr = (function(d, s, id) {var js, fjs = d.getElementsByTagName(s)[0],t = window.twttr || {};if (d.getElementById(id)) return t;js = d.createElement(s);js.id = id;js.src = "https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, "script", "twitter-wjs"));</script>
    </div>
    <!-- End Blog Latest Tweets -->
</div>
<!-- End Right Sidebar -->
</div>
<!--/row-->
</div>
<!--/container-->


<!--=== Copyright ===-->
<div class="footer-default">
    <div class="copyright">
        <div class="container">
            <div class="row">
                <div class="col-md-8">
                    <p class="copyright-space">
                         Company Registration No: 8712584
                         | Contact us: <a href="mailto:hello@codurance.com" class="">hello@codurance.com</a>
                         | Phone: +44 203 440 4015
                    </p>

                </div>
                <div class="col-md-4">
                    <ul class="social-icons pull-right">
                        <li><a href="/atom.xml" data-original-title="Feed" class="social_rss"></a></li>
                        <li><a href="http://twitter.com/codurance" data-original-title="Twitter" class="social_twitter"></a></li>
                    </ul>
                </div>
            </div> <!--/row-->
        </div> <!--/container-->
    </div><!--/copyright-->
</div>

<!--=== End Copyright ===-->
</div>

<!-- JS Global Compulsory -->
<script type="text/javascript" src="/assets/plugins/jquery/jquery.min.js"></script>
<script type="text/javascript" src="/assets/plugins/jquery/jquery-migrate.min.js"></script>
<script type="text/javascript" src="/assets/plugins/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/assets/plugins/back-to-top.js"></script>
<!-- JS Implementing Plugins -->
<script type="text/javascript" src="/assets/plugins/owl-carousel/owl-carousel/owl.carousel.js"></script>
<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
<script type="text/javascript" src="/assets/plugins/gmap/gmap.js"></script>
<!-- JS Customization -->
<script type="text/javascript" src="/assets/js/custom.js"></script>
<!-- JS Page Level -->
<script type="text/javascript" src="/assets/js/app.js"></script>
<script type="text/javascript" src="/assets/js/pages/index.js"></script>

<script type="text/javascript">
    jQuery(document).ready(function() {
        App.init();
        Index.initOwlCarousel();
        Contact.initMap();
    });
</script>
<!--[if lt IE 9]>
    <script src="/assets/plugins/respond.js"></script>
    <script src="/assets/plugins/html5shiv.js"></script> 
    <script src="/assets/js/plugins/placeholder-IE-fixes.js"></script>   
<![endif]-->

</body>
</html>
